# 判断与循环结构

这节课介绍Python的两大逻辑，判断和循环。其中，判断有`if...else...`和`if...elif...else...`，循环包括`for...in...`和`while`。Python代码是顺序执行的，而这两类结构会使代码增添很多逻辑，简单几行就能执行非常复杂的任务。

在逻辑结构中，代码与代码之间需要有层次，比如控制循环次数的和每次循环时需要执行的代码。Python使用缩进的方式来区分代码的结构层次，具体的使用方法我会在下面的例子中进行解释。

## 1. 判断

在讲解判断结构之前，首先需要了解一下如何比较两个值的关系，通俗点说就是大小关系和相等关系。Python中用于比较关系的符号可见下表：

逻辑关系|符号
---|---
大于|>
大于等于|>=
小于|<
小于等于|<=
相等|==
不等|!=
逻辑与|and
逻辑或|or
逻辑非|not

来看下面这个例子：
```python
a = 8
if a <= 10:
    print('a小于等于10')
else:
    print('a大于10')
```
大家应该能猜到这段代码执行的结果是打印出了`a小于等于10`。大家可以改变一下a的值，看看结果是不是跟预期的一样。

为了解释一下`and, or, not`的使用，可以把上面的代码进行如下的拆解：
```python
a = 8
if a < 10 or a == 10:  # 与上面的例子是一个意思
    print('a小于等于10')
else:
    print('a大于10')
```

```python
a = 8
if not (a > 10):  # 不确定执行顺序的时候，毫不犹豫地加括号上去
    print('a小于等于10')
else:
    print('a大于10')
```

使用`if...elif...else...`进行多个条件的判断，请看下面这个例子
```python
a = 8
if a <= 5:
    print('a小于等于5')
elif a > 5 and a <= 10:
    print('a大于五小于等于10')
else:
    print('a大于10')
```
即`elif`后面要加上判别式，其他的跟`if...else...`一样。



## 2. 循环

循环结构，顾名思义就是反复执行一段代码。

### 2.1 for循环

for循环非常常用，语法结构也非常简单，比如下面的例子：

```python
cars = ['Benz', 'Audi', 'BMW', 'Toyota', 'BYD']
for i in range(len(cars)):
    print(cars[i])
```

这段代码执行结果是逐个打印出`cars`中的元素。这里有三点需要解释一下：
- `len(cars)`其中的`len()`函数是获取`cars`中元素的个数，这个例子中返回`5`
- `range(len(cars))`其实就是`range(5)`，而`range()`这个函数将产生一个整数的可迭代对象，即从0开始，每次结束一个循环时都会在前一个值+1，也就是说`i`在第一次循环时为`0`，第二次循环时为`1`，以此类推，一共循环5次，最后一个`i`为`4`；
- `print(cars[i])`即每次循环时执行的操作，比如第一次循环时`i`为`0`，那么想必大家都知道`print(cars[0])`表示什么意思了吧；
- 大家还要注意冒号和缩进。缩进是一个`tab`键，而不是空格。在很多集成开发环境中，输入完冒号后按回车，第二行会自动缩进，如果不能自动缩进的，按一下`Tab`键即可。

大家以后如果对什么东西不确定，其实可以使用`print()`函数把想知道的打印出来，比如刚刚这段代码，我们可以这样检查：
```python
cars = ['Benz', 'Audi', 'BMW', 'Toyota', 'BYD']
print(f'len(cars)的结果为：{len(cars)}')
for i in range(len(cars)):
    print(f'此时i为：{i}')
    print(cars[i])
```

这里提到了可迭代对象的概念，大家暂时不用弄懂它，只需要知道`range()`的功能即可。

另外，一个列表也是一个可迭代对象，那么我们完全可以直接把列表放在`in`的后面，比如下面这样

```python
cars = ['Benz', 'Audi', 'BMW', 'Toyota', 'BYD']
for i in cars:
    print(i)
```

在命名变量时要准确传达变量所代表的意思，上面代码中的`i`并不能准确传达具体的意思，换成`car`会更直白：

```python
cars = ['Benz', 'Audi', 'BMW', 'Toyota', 'BYD']
for car in cars:
    print(car)
```

### 2.2 while循环

`while`在英语里有“当...”的意思，在Python中也可以这样理解。`while`后面要接一个条件判别式。请看下面这个代码：

```python
cars = ['Benz', 'Audi', 'BMW', 'Toyota', 'BYD']
i = 0
while i <= 4:
    print(cars[i])
    i = i + 1
```
这段代码同样也是打印`cars`中各个元素。`i`最开始被赋值为`0`。当执行`while i <= 4:`时，`i`显然是满足条件的，所以要执行下面两行代码。此时`i`为`0`。`print(cars[i])`是打印`car[0]`，即`Benz`。`i = i + 1`这行有点意思，这行代码表示先计算`i + 1`，再讲其赋值给`i`，即更新`i`的值，使其+1。第一次循环结束后`i`变为`1`了，显然还是满足条件，所以还要再执行下面两行代码。以此类推，直到`i`等于`5`时，不满足上面的条件了，所以循环终止，整个代码运行结束。

## 3. 判断与循环的综合应用：排序

现在我们用上面学到的判断与循环结构，联合之前学到的列表的有关知识点，做一个排序算法。

### 3.1 问题描述

假设有一个内部元素都是数字的列表`number = [5, 2.7, 8.2, 7, 23.9, 23.8, 11, 29, 11, 40, -3]`，它里面有整数，有小数，还有相同的数。我们想让它从小到大排序，对于重复的元素都要保留。

这里不使用太复杂的算法，而是用穷举法，简单暴力且直接。现在给大家两分钟的时间，想一想怎么将排序的方法写成计算机能理解的逻辑？

> **提示**：可以从下面几个问题入手：
>
> - 应该先找到最小值还是最大值？
> - 我们找到当前最大或者最小值后，这个值在后续比较中还有必要存在吗？

### 3.2 解决方案

现在揭晓答案。其实如果我们使用升序排列，当然是先找到最小值更为方便。

为了找到最小值，我们需要选取一个初值作为基准。虽说这个初值选列表中哪个都不影响找到最小值，但是如果我们找到了最小值，就会把这个值从`number`列表中删掉，列表长度就会缩短。所以这个初值需要是列表的第一个值， 这样就能保证每次都能有一个值作为比较的基数。具体代码实现如下：

```python
values = [5, 2.7, 8.2, 7, 23.9, 23.8, 11, 29, 11, 40, -3]
sorted_values = []           # 初始化一个空列表用于存放当前最小值

while len(values) != 0:      # 只要values不为空，就循环
    minimum = values[0]      # 先选取values第一个值为基数
    for value in values:     # 遍历values中所有值
        if value < minimum:  
            minimum = value  # 如果这个值比基数小，就更新基数
    # 遍历完当前values后，确定了最小值，将这个最小值存入sorted_values
    sorted_values.append(minimum)  
    # 从当前values中删除这个最小值，因为不需要它参与后续的比较。
    # 此时values减少一个元素
    values.remove(minimum)  

print(sorted_values)
```

这个问题还可以有另一种方法，即直接在`values`上交换位置，第一次将全局最小值放在第一位，第二次将次最小值放在第二位，以此类推。

虽然概念上易懂，但代码没有上面的直观，补充在这里以供大家参考。

总行数（除了注释）会比上面的代码少两行，但并不意味着计算开销就会减少，因为本质上也是穷举法。

```python
values = [5, 2.7, 8.2, 7, 23.9, 23.8, 11, 29, 11, 40, -3]

for i in range(len(values)):  
    for j in range(i, len(values)):
        if values[j] < values[i]:
            temp = values[i]
            values[i] = values[j]
            values[j] = temp

print(values)
```
> - 大家可以看到，同样一个功能可能会有多种实现方式，具体选择哪种要根据具体情况而定。
> - 如果选择降序排列，那么上面代码应该怎么修改呢？